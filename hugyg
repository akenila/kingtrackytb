def is_valid_cookie_file(cookie_path):
    if not os.path.exists(cookie_path):
        return False
    try:
        with open(cookie_path, 'r', encoding='utf-8') as f:
            content = f.read()
            if not content.strip():
                return False
            if '# Netscape HTTP Cookie File' not in content:
                return False
        return True
    except Exception:
        return False

# Biến toàn cục
COOKIE_FILE = 'cookies.txt'
RESULTS_DIR = 'Results'
PROCESSED_IDS_FILE = 'processed_ids.txt'
CONFIG_FILE = 'config.txt'
PROCESSED_URLS_FILE = 'processed_urls.txt'

# Cấu hình ffmpeg giống file .bat, cho phép nhập đường dẫn ffmpeg
DEFAULT_FFMPEG_PATH = './ffmpeg'
FFMPEG_TEMPLATE = (
    '"{ffmpeg_path}" -ss 00:00:00.5 -y -i "{video_path}" -i "{overlay_img}" '
    '-filter_complex "[0:v]setpts=PTS/1,crop=iw/1.0:ih/1.0,scale=720:720,setdar=1[v];'
    'movie={bg_video}:loop=999,setpts=N/(FRAME_RATE*TB),scale=720:720,setdar=1[bg];'
    '[bg][v]overlay=shortest=1:x=0:y=0[v1];[v1][1:v]overlay=0:0;[0:a]atempo=1,'
    'aformat=sample_fmts=fltp:sample_rates=44100:channel_layouts=stereo" '
    '-vcodec libx264 -pix_fmt yuv420p -r 30 -g 60 -b:v 1600k -profile:v main -level 3.1 '
    '-codec:a aac -b:a 128k -ar 44100 -s 720x720 -preset superfast "{output_path}"'
)

os.makedirs(RESULTS_DIR, exist_ok=True)

if os.path.exists(PROCESSED_IDS_FILE):
    with open(PROCESSED_IDS_FILE, 'r', encoding='utf-8') as f:
        processed_ids = set(line.strip() for line in f)
else:
    processed_ids = set()
if os.path.exists(PROCESSED_URLS_FILE):
    with open(PROCESSED_URLS_FILE, 'r', encoding='utf-8') as f:
        processed_urls = set(line.strip() for line in f)
else:
    processed_urls = set()

def split_profile_path(full_path):
    # Ví dụ: G:/Job/YoutubeTracking/ChromePortable/Data/profile/Profile 1
    import os
    norm_path = os.path.normpath(full_path)
    parts = norm_path.split(os.sep)
    if len(parts) >= 2:
        profile_dir = parts[-1]
        profile_path = os.sep.join(parts[:-1])
        return profile_path, profile_dir
    return full_path, 'Default'
import undetected_chromedriver as uc

import undetected_chromedriver as uc
from webdriver_manager.chrome import ChromeDriverManager
SETTINGS_FILE = 'settings.txt'
def endtask_chrome_portable(target_exe_path):
    target_exe_path = os.path.abspath(target_exe_path)  # Chuyển relative path thành absolute path
    target_exe_path = os.path.normcase(target_exe_path) # Normalize path cho Windows (bỏ phân biệt hoa/thường)
    print(f"Target exe path after normalize: {target_exe_path}")
    
    count = 0
    for proc in psutil.process_iter(['pid', 'exe', 'name']):
        try:
            exe_path = proc.info['exe']
            if exe_path:
                exe_path_norm = os.path.normcase(exe_path)
                if exe_path_norm == target_exe_path:
                    print(f"Terminating PID={proc.pid}, exe={exe_path}")
                    proc.terminate()
                    count += 1
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            continue
    print(f"Đã terminate {count} tiến trình có exe path: {target_exe_path}")

def get_cookie_with_profile(full_profile_path, chrome_path='./ChromePortable/GoogleChromePortable.exe'):
    profile_path, profile_dir = split_profile_path(full_profile_path)
    endtask_chrome_portable(r"./ChromePortable/App/Chrome-bin/chrome.exe")
    options = uc.ChromeOptions()
    options.add_argument(f"--user-data-dir={profile_path}")
    options.add_argument(f"--profile-directory={profile_dir}")
    driver_path = ChromeDriverManager(driver_version="127.0.6533.120").install()
    driver = uc.Chrome(options=options, browser_executable_path=chrome_path, driver_executable_path=driver_path)
    driver.get("https://www.youtube.com/feed/subscriptions")
    def to_netscape(cookies, domain=None):
        lines = ["# Netscape HTTP Cookie File", ""]
        for c in cookies:
            domain_str = c['domain'] if 'domain' in c else domain or 'youtube.com'
            flag = 'TRUE' if domain_str.startswith('.') else 'FALSE'
            path = c.get('path', '/')
            secure = 'TRUE' if c.get('secure', False) else 'FALSE'
            expires = str(c.get('expiry', 0))
            name = c.get('name', '')
            value = c.get('value', '')
            lines.append(f"{domain_str}\t{flag}\t{path}\t{secure}\t{expires}\t{name}\t{value}")
        return '\n'.join(lines)
    cookies = driver.get_cookies()
    netscape_cookies = to_netscape(cookies)
    with open('cookies.txt', 'w', encoding='utf-8') as f:
        f.write(netscape_cookies)
    driver.quit()
    endtask_chrome_portable(r"./ChromePortable/App/Chrome-bin/chrome.exe")
    print(f"Đã lấy lại cookie với profile path: {profile_path}, profile dir: {profile_dir}")


def process_video(video):
    video_id = video.get('id')
    channel = video.get('uploader') or 'Unknown'
    video_url = video.get('url') or f'https://www.youtube.com/watch?v={video_id}'
    # Đọc ánh xạ kênh -> folder
    channel_folder = load_channel_folder_map()
    if channel in channel_folder:
        folder_name = channel_folder[channel]
    else:
        import uuid
        folder_name = f'Channel_{uuid.uuid4().hex[:8]}'
        channel_folder[channel] = folder_name
        save_channel_folder_map(channel_folder)
    folder = os.path.join(RESULTS_DIR, folder_name)
    os.makedirs(folder, exist_ok=True)
    video_file = os.path.join(folder, f'{video_id}.mp4')
    thumb_file = os.path.join(folder, f'{video_id}_1s.jpg')
    download_video(video_url, video_file)
    extract_thumbnail(video_file, thumb_file)
    save_processed_id(video_id)
    save_processed_url(video_url)



def process_manual_links(links, folder_name):
    channel_folder = load_channel_folder_map()
    # Kiểm tra cookie trước khi tải
    import tkinter as tk
    from tkinter import messagebox
    # Nếu file cookie rỗng hoặc sai định dạng thì lấy lại cookie
    if not is_valid_cookie_file(COOKIE_FILE):
        # Hỏi người dùng nhập profile path nếu chưa có
        root = tk._default_root
        profile_path = None
        if root:
            for widget in root.winfo_children():
                if isinstance(widget, tk.Entry) and widget.get():
                    profile_path = widget.get()
                    break
        if not profile_path:
            profile_path = ''
        messagebox.showinfo('Cookie', 'Cookie rỗng hoặc sai định dạng, đang lấy lại cookie...')
        get_cookie_with_profile(profile_path)
    for link in links:
        ydl_opts = {
            'cookiefile': COOKIE_FILE,
            'outtmpl': os.path.join(RESULTS_DIR, '%(id)s.%(ext)s'),
            'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
            'ffmpeg_location': './ffmpeg/bin/ffmpeg.exe',
            'merge_output_format': 'mp4',
        }
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(link, download=True)
            video_id = info.get('id')
            channel = info.get('uploader') or 'Unknown'
            # Ánh xạ kênh sang folder
            if channel in channel_folder:
                folder_name_for_channel = channel_folder[channel]
            else:
                import uuid
                folder_name_for_channel = f'Channel_{uuid.uuid4().hex[:8]}'
                channel_folder[channel] = folder_name_for_channel
                save_channel_folder_map(channel_folder)
            folder_for_channel = os.path.join(RESULTS_DIR, folder_name_for_channel)
            os.makedirs(folder_for_channel, exist_ok=True)
            video_file = os.path.join(folder_for_channel, f'{video_id}.mp4')
            thumb_file = os.path.join(folder_for_channel, f'{video_id}_1s.jpg')
            extract_thumbnail(video_file, thumb_file)
            save_processed_id(video_id)
            save_processed_url(f"https://www.youtube.com/watch?v={video_id}")

def start_scan(scan_time_var, num_videos_var, profile_path_var, status_var):
    def scan_loop():
        scan_time = int(scan_time_var.get())
        num_videos = int(num_videos_var.get())
        profile_path = profile_path_var.get().strip()
        while True:
            # Kiểm tra cookie trước mỗi lần quét
            if is_valid_cookie_file(COOKIE_FILE) == False:
                status_var.set('Cookie rỗng hoặc sai định dạng, đang lấy lại cookie...')
                get_cookie_with_profile(profile_path)
            status_var.set('Đang quét video mới...')
            try:
                new_videos = get_new_videos_from_subscriptions(num_videos)
                if len(new_videos) == 0 and profile_path:
                    status_var.set('Không extract được video, đang lấy lại cookie...')
                    get_cookie_with_profile(profile_path)
                    new_videos = get_new_videos_from_subscriptions(num_videos)
                for video in new_videos:
                    status_var.set(f'Đang xử lý: {video.get("title")}')
                    process_video(video)
                status_var.set(f'Hoàn thành quét!, Chờ {scan_time} giây để quét tiếp...')
            except Exception as e:
                status_var.set(f'Lỗi: {e}')
            time.sleep(scan_time)
    threading.Thread(target=scan_loop, daemon=True).start()

def save_processed_id(video_id):
    processed_ids.add(video_id)
    with open(PROCESSED_IDS_FILE, 'a', encoding='utf-8') as f:
        f.write(video_id + '\n')
def save_processed_url(video_url):
    processed_urls.add(video_url)
    with open(PROCESSED_URLS_FILE, 'a', encoding='utf-8') as f:
        f.write(video_url + '\n')


# Đọc ánh xạ kênh -> folder từ config.txt
def load_channel_folder_map():
    channel_folder = {}
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if ':' in line:
                    folder, channel = line.split(':', 1)
                    channel_folder[channel] = folder
    return channel_folder

# Lưu ánh xạ mới vào config.txt
def save_channel_folder_map(channel_folder):
    with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
        for channel, folder in channel_folder.items():
            f.write(f'{folder}:{channel}\n')

# Thêm ánh xạ mới
def add_channel_folder(channel_folder, channel, folder):
    channel_folder[channel] = folder
    save_channel_folder_map(channel_folder)

def get_new_videos_from_subscriptions(num_videos):
    import time
    ydl_opts = {
        'cookiefile': COOKIE_FILE,
        'playlistend': num_videos,
        'skip_download': True,
        'ffmpeg_location': './ffmpeg/bin/ffmpeg.exe',
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info = ydl.extract_info('https://www.youtube.com/feed/subscriptions')
        videos = info.get('entries', [])
        new_videos = []
        now = int(time.time())
        for video in videos:
            video_id = video.get('id')
            video_url = video.get('url') or f'https://www.youtube.com/watch?v={video_id}'
            duration = video.get('duration')
            is_live = video.get('is_live') or video.get('was_live_streamed')
            availability = video.get('availability')
            release_timestamp = video.get('release_timestamp')
            scheduled_start_time = video.get('scheduled_start_time')
            # Lọc: không tải video live, không tải video > 1h30p, không tải nếu đã có id hoặc url
            # Bổ sung: không tải video chưa đăng (upcoming/premiere)
            if not video_id or not video_url:
                continue
            if (video_id in processed_ids) or (video_url in processed_urls):
                continue
            if is_live:
                continue
            if duration is not None and duration > 5400:
                continue
            # Lọc video chưa đăng (upcoming/premiere)
            if availability in ['private', 'unlisted', 'scheduled', 'premiere']:
                continue
            if (release_timestamp and release_timestamp > now) or (scheduled_start_time and scheduled_start_time > now):
                continue
            new_videos.append(video)
        return new_videos

def download_video(video_url, output_path):
    # Đảm bảo folder tồn tại
    folder = os.path.dirname(os.path.abspath(output_path))
    os.makedirs(folder, exist_ok=True)
    ydl_opts = {
        'cookiefile': COOKIE_FILE,
        'outtmpl': output_path,
        'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
        'ffmpeg_location': './ffmpeg/bin/ffmpeg.exe',
        'merge_output_format': 'mp4',
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        ydl.download([video_url])

def extract_thumbnail(video_path, output_path):
    cap = cv2.VideoCapture(video_path)
    cap.set(cv2.CAP_PROP_POS_MSEC, 1000)
    ret, frame = cap.read()
    if ret:
        cv2.imwrite(output_path, frame)
    cap.release()

def process_manual_links(links, folder_name):
    channel_folder = load_channel_folder_map()
    for link in links:
        ydl_opts = {
            'cookiefile': COOKIE_FILE,
            'outtmpl': os.path.join(RESULTS_DIR, '%(id)s.%(ext)s'),
            'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
            'ffmpeg_location': './ffmpeg/bin/ffmpeg.exe',
            'merge_output_format': 'mp4',
        }
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(link, download=True)
            video_id = info.get('id')
            channel = info.get('uploader') or 'Unknown'
            # Ánh xạ kênh sang folder
            if channel in channel_folder:
                folder_name_for_channel = channel_folder[channel]
            else:
                import uuid
                folder_name_for_channel = f'Channel_{uuid.uuid4().hex[:8]}'
                channel_folder[channel] = folder_name_for_channel
                save_channel_folder_map(channel_folder)
            folder_for_channel = os.path.join(RESULTS_DIR, folder_name_for_channel)
            os.makedirs(folder_for_channel, exist_ok=True)
            video_file = os.path.join(folder_for_channel, f'{video_id}.mp4')
            thumb_file = os.path.join(folder_for_channel, f'{video_id}_1s.jpg')
            extract_thumbnail(video_file, thumb_file)
            save_processed_id(video_id)
            save_processed_url(f"https://www.youtube.com/watch?v={video_id}")

def start_scan(scan_time_var, num_videos_var, profile_path_var, status_var):
    def scan_loop():
        scan_time = int(scan_time_var.get())
        num_videos = int(num_videos_var.get())
        profile_path = profile_path_var.get().strip()
        global processed_ids, processed_urls
        while True:
            # Kiểm tra cookie trước mỗi lần quét
            if not is_valid_cookie_file(COOKIE_FILE) and profile_path:
                status_var.set('Cookie rỗng hoặc sai định dạng, đang lấy lại cookie...')
                get_cookie_with_profile(profile_path)
                # Kiểm tra lại sau khi lấy cookie
                if not is_valid_cookie_file(COOKIE_FILE):
                    status_var.set('Không thể lấy lại cookie hợp lệ. Vui lòng kiểm tra lại profile path hoặc đăng nhập lại YouTube.')
                    time.sleep(scan_time)
                    continue
            # Đọc lại file id và url trước mỗi lần quét
            if os.path.exists(PROCESSED_IDS_FILE):
                with open(PROCESSED_IDS_FILE, 'r', encoding='utf-8') as f:
                    processed_ids = set(line.strip() for line in f)
            if os.path.exists(PROCESSED_URLS_FILE):
                with open(PROCESSED_URLS_FILE, 'r', encoding='utf-8') as f:
                    processed_urls = set(line.strip() for line in f)
            status_var.set('Đang quét video mới...')
            try:
                new_videos = get_new_videos_from_subscriptions(num_videos)
                if len(new_videos) == 0 and profile_path:
                    status_var.set('Không extract được video, đang lấy lại cookie...')
                    get_cookie_with_profile(profile_path)
                    # Kiểm tra lại sau khi lấy cookie
                    if not is_valid_cookie_file(COOKIE_FILE):
                        status_var.set('Không thể lấy lại cookie hợp lệ. Vui lòng kiểm tra lại profile path hoặc đăng nhập lại YouTube.')
                        time.sleep(scan_time)
                        continue
                    new_videos = get_new_videos_from_subscriptions(num_videos)
                for video in new_videos:
                    status_var.set(f'Đang xử lý: {video.get("title")}')
                    process_video(video)
                # Đồng bộ file id và url sau mỗi lần quét
                # Nếu file url có link mà file id chưa có thì add thêm id vào file id
                url_to_id = {}
                if os.path.exists(PROCESSED_URLS_FILE):
                    with open(PROCESSED_URLS_FILE, 'r', encoding='utf-8') as f:
                        for url in f:
                            url = url.strip()
                            if url and 'watch?v=' in url:
                                vid = url.split('watch?v=')[-1].split('&')[0]
                                url_to_id[url] = vid
                missing_ids = [vid for url, vid in url_to_id.items() if vid and vid not in processed_ids]
                if missing_ids:
                    with open(PROCESSED_IDS_FILE, 'a', encoding='utf-8') as f:
                        for vid in missing_ids:
                            f.write(vid + '\n')
                            processed_ids.add(vid)
                status_var.set(f'Hoàn thành quét!, Chờ {scan_time} giây để quét tiếp...')
            except Exception as e:
                status_var.set(f'Lỗi: {e}')
            time.sleep(scan_time)
    threading.Thread(target=scan_loop, daemon=True).start()

def process_links(links_text, folder_var, status_var):
    def links_thread():
        links = links_text.get('1.0', tk.END).strip().splitlines()
        folder_name = folder_var.get().strip()
        if links and folder_name:
            status_var.set('Đang xử lý link nhập...')
            try:
                process_manual_links(links, folder_name)
                status_var.set('Hoàn thành xử lý link nhập!')
            except Exception as e:
                status_var.set(f'Lỗi: {e}')
    threading.Thread(target=links_thread, daemon=True).start()

def browse_file(entry):
    filename = filedialog.askopenfilename()
    if filename:
        entry.delete(0, tk.END)
        entry.insert(0, filename)

def main():
    root = tk.Tk()
    root.title('YouTube Auto Downloader')

    # Giá trị mặc định
    default_scan_time = '30'
    default_num_videos = '5'
    default_profile_path = ''
    default_folder = 'Manual'

    # Load từ file settings.txt nếu có
    scan_time = default_scan_time
    num_videos = default_num_videos
    profile_path = default_profile_path
    folder = default_folder
    if os.path.exists(SETTINGS_FILE):
        try:
            with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                for line in f:
                    if line.startswith('Thời gian quét:'):
                        scan_time = line.split(':',1)[1].strip()
                    elif line.startswith('Số video muốn quét:'):
                        num_videos = line.split(':',1)[1].strip()
                    elif line.startswith('Profile path:'):
                        profile_path = line.split(':',1)[1].strip()
                    elif line.startswith('Tên folder:'):
                        folder = line.split(':',1)[1].strip()
        except Exception:
            pass

    tk.Label(root, text='Thời gian quét (giây):').grid(row=0, column=0)
    scan_time_var = tk.StringVar(value=scan_time)
    tk.Entry(root, textvariable=scan_time_var).grid(row=0, column=1)
    tk.Label(root, text='Số video muốn quét:').grid(row=1, column=0)
    num_videos_var = tk.StringVar(value=num_videos)
    tk.Entry(root, textvariable=num_videos_var).grid(row=1, column=1)
    tk.Label(root, text='Profile path:').grid(row=2, column=0)
    profile_path_var = tk.StringVar(value=profile_path)
    tk.Entry(root, textvariable=profile_path_var, width=50).grid(row=2, column=1)
    tk.Label(root, text='Nhập link video (mỗi dòng 1 link):').grid(row=3, column=0)
    links_text = tk.Text(root, height=5, width=50)
    links_text.grid(row=3, column=1)
    tk.Label(root, text='Tên folder cho link nhập:').grid(row=4, column=0)
    folder_var = tk.StringVar(value=folder)
    tk.Entry(root, textvariable=folder_var).grid(row=4, column=1)
    status_var = tk.StringVar()
    tk.Label(root, textvariable=status_var).grid(row=5, column=0, columnspan=2)
    tk.Button(root, text='Bắt đầu quét', command=lambda: start_scan(scan_time_var, num_videos_var, profile_path_var, status_var)).grid(row=6, column=0)
    tk.Button(root, text='Xử lý link nhập', command=lambda: process_links(links_text, folder_var, status_var)).grid(row=6, column=1)
    def save_settings():
        with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
            f.write(f'Thời gian quét: {scan_time_var.get()}\n')
            f.write(f'Số video muốn quét: {num_videos_var.get()}\n')
            f.write(f'Profile path: {profile_path_var.get()}\n')
            f.write(f'Tên folder: {folder_var.get()}\n')
    tk.Button(root, text='Lưu setting', command=save_settings).grid(row=7, column=0, columnspan=2)
    root.mainloop()

if __name__ == '__main__':
    main()
